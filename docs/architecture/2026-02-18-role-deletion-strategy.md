# 角色删除策略与系统一致性方案 (2026-02-18)

## 背景

探讨关于 B 端（管理后台）删除或禁用角色对 C 端（App/家庭）数据一致性及用户体验的影响。

## 核心问题

系统采用 **引用模式 (Reference Model)**，所有家庭共用一套系统角色（`family_id` 为空）。
如果管理员在 B 端删除或禁用了某个角色：

1.  **数据一致性**：C 端家庭中现有的用户仍然持有这些无效角色的引用。
2.  **业务逻辑**：像 `OWNER`（拥有者）和 `GUEST`（访客）这样的关键角色是家庭运作的基础。移除它们会导致系统崩溃。

## 建议策略：系统角色保护

### 1. 角色分类

将角色分为两类：

- **系统角色 (受保护)**：`OWNER`, `GUEST`
- **自定义/普通角色**：`MEMBER`, `ADMIN` 等

### 2. 保护规则

为了在不引入复杂的“软删除”或“迁移”逻辑的前提下确保系统稳定性：

#### A. 系统角色 (`OWNER`, `GUEST`)

- **动作**：**严格保护**。
- **规则**：
  - **删除**：禁止。尝试操作时 API 必须返回错误。
  - **禁用**：禁止。尝试操作时 API 必须返回错误。
- **理由**：这些角色是 C 端业务逻辑中的硬编码依赖。移除它们会导致系统立即故障。

#### B. 普通角色

- **动作**：**允许删除/禁用**。
- **后果**：
  - 持有这些角色的用户将拥有无效的 `role_id` 引用。
  - **兜底机制 (安全网)**：
    - 当 C 端鉴权检测到无效角色（已删除或已禁用）时：
    - **不要** 抛出 403 Forbidden 或踢出用户。
    - **自动降级**：在内存/会话中临时赋予 `GUEST` 权限。
    - **用户体验**：用户仍可登录，但权限受限。家庭拥有者 (Owner) 必须手动为该用户重新分配有效角色。

## 实施清单 (未来规划)

- [ ] **后端 (Admin API)**：
  - 在 `delete` 和 `update` (状态) 接口中，增加 `isSystem` 标识检查或比对保留的 `roleCode` 列表 (`OWNER`, `GUEST`)。
  - 如果尝试修改系统角色，抛出 `400 Bad Request`。
- [ ] **后端 (App API / Auth Guard)**：
  - 实现兜底逻辑：如果 `user.role` 无效/已删除/已禁用 -> 将 `GUEST` 权限注入请求上下文。

## 决策

采用 **系统角色保护** 策略。

- B 端保留控制权，但防止破坏系统关键数据。
- C 端对受角色删除影响的用户实施优雅降级（回退至 Guest）。
